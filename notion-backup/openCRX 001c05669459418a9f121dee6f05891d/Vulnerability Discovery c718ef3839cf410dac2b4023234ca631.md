# Vulnerability Discovery

## Java Archive Application Structure

openCRX runs on Apache TomEE. 

Java web applications can be packaged in several different file formats, including JARs, WARs and EARs, which are essentially ZIP files with different extensions.

1. Java Archive (JAR) files are used for stand-alone applications or libraries (think: webshell)
2. Web Application Archive (WAR) files are used to collect multiple JARs and static content (HTML/CSS) into a single archive. 
3. EARs contain multiple JARs and WARs to consolidate multiple web applications into a single file

When inspecting the file structure of openCRX (`tree -L 3`), we find the EAR file `/home/student/crx/apache-tomee-plus-7.0.5/apps/opencrx-core-CRX.ear`. In an adjacent folder, there are several WAR files inside, but these files are likely already packaged within the EAR file. We’ll then unzip the package with `unzip -q opencrx-core-CRX.ear -d opencrx`. 

- Common JAR files are found in `/APP-INF/lib`
- The main application, `opencrx-core-CRX.war` can be opened and inspected in JD_GUI

## WAR file inspection

When we open `opencrx-core-CRX.war` in JD_GUI, we find quite a few JSP files that involve authentication and password resets. Let’s first look at `RequestPasswordReset.jsp` to understand the process of issuing codes and handling password resets. 

In that file, several **custom** libraries are being imported. 

```java
%><%@ page session="true" import="
java.util.*,
java.net.*,
java.util.Enumeration,
java.io.PrintWriter,
org.w3c.spi2.*,
org.openmdx.portal.servlet.*,
org.openmdx.base.naming.*,
org.opencrx.kernel.generic.*
"%>
```

Here is the main application logic. If we want to trigger a successful password reset, we need to reach the line of code `userHome.requestPasswordReset();`

- The `if` statement just above it must evaluate to true — `principalName`, `providerName`, and `segmentName` all cannot be equal to `null`.
- The `pm.getObjectById` method uses those values to get an `org.opencrx.kernel.home1.jmi1.UserHome` object.
- We then need to trace back the `requestPasswordReset` method on this object and continue tracing password logic. EAR files contain an `application.xml` file within `META-INF`that contains deployment information, including the location of **external libraries**.

```java
Boolean success = null;
String id = request.getParameter("id");
if(
	id != null && !id.isEmpty()
) {
	final Path LOGIN_REALM_IDENTITY = new Path("xri://@openmdx*org.openmdx.security.realm1/provider/CRX/segment/Root/realm/Default");

	String principalName = null;
	String providerName = null;
	String segmentName = null;
	
	int pos1 = id.indexOf("@");
	int pos2 = id.indexOf("/");
	if(pos1 > 0 && pos2 > pos1) {	
		// Format 1: principal@provider/segment
		principalName = id.substring(0, pos1);
		providerName = id.substring(pos1 + 1, pos2);
		segmentName = id.substring(pos2 + 1);
	} else if(pos1 > 0) {
		// Format 2: mail@domain
		javax.jdo.PersistenceManagerFactory pmf = org.opencrx.kernel.utils.Utils.getPersistenceManagerFactory();
		javax.jdo.PersistenceManager pmRoot = pmf.getPersistenceManager(
			SecurityKeys.ROOT_PRINCIPAL, 
			null
		);
        org.openmdx.security.realm1.jmi1.Segment realmSegment =
            (org.openmdx.security.realm1.jmi1.Segment)pmRoot.getObjectById(LOGIN_REALM_IDENTITY.getParent().getParent());
        int count = 0;
        for(org.openmdx.security.realm1.jmi1.Realm realm: realmSegment.<org.openmdx.security.realm1.jmi1.Realm>getRealm()) {
            if(!realm.refGetPath().equals(LOGIN_REALM_IDENTITY) && !"Root".equals(realm.refGetPath().getLastSegment().toClassicRepresentation())) {
       			String currentProviderName = realm.refGetPath().getSegment(2).toClassicRepresentation();
       			String currentSegmentName = realm.refGetPath().getLastSegment().toClassicRepresentation();
    			javax.jdo.PersistenceManager pm = pmf.getPersistenceManager(
					SecurityKeys.ADMIN_PRINCIPAL + SecurityKeys.ID_SEPARATOR + currentSegmentName, 
					null
				);
            	org.opencrx.kernel.home1.jmi1.Segment userHomeSegment = org.opencrx.kernel.backend.UserHomes.getInstance().getUserHomeSegment(pm, currentProviderName, currentSegmentName);
            	org.opencrx.kernel.home1.cci2.EMailAccountQuery emailAccountQuery = (org.opencrx.kernel.home1.cci2.EMailAccountQuery)org.openmdx.base.persistence.cci.PersistenceHelper.newQuery(
		    		pm.getExtent(org.opencrx.kernel.home1.jmi1.EMailAccount.class),
		    		userHomeSegment.refGetPath().getDescendant("userHome", ":*", "eMailAccount", ":*")
		    	);
            	emailAccountQuery.thereExistsIsActive().isTrue();
            	emailAccountQuery.name().equalTo(id);
				List<org.opencrx.kernel.home1.jmi1.EMailAccount> emailAccounts = userHomeSegment.getExtent(emailAccountQuery);
				if(emailAccounts.size() == 1) {
					org.opencrx.kernel.home1.jmi1.EMailAccount emailAccount = emailAccounts.iterator().next();
					principalName = emailAccount.refGetPath().getParent().getParent().getLastSegment().toClassicRepresentation();
					providerName = currentProviderName;
					segmentName = currentSegmentName;
					count++;
				}
				pm.close();
            }
        }
        // id is not unique --> no success
        if(count > 1) {
        	principalName = null;
        }
        pmRoot.close();
	} else {
		// Format 3: principal
		javax.jdo.PersistenceManagerFactory pmf = org.opencrx.kernel.utils.Utils.getPersistenceManagerFactory();
		javax.jdo.PersistenceManager pmRoot = pmf.getPersistenceManager(
			SecurityKeys.ROOT_PRINCIPAL, 
			null
		);			
        org.openmdx.security.realm1.jmi1.Segment realmSegment =
            (org.openmdx.security.realm1.jmi1.Segment)pmRoot.getObjectById(LOGIN_REALM_IDENTITY.getParent().getParent());
        int count = 0;
        for(org.openmdx.security.realm1.jmi1.Realm realm: realmSegment.<org.openmdx.security.realm1.jmi1.Realm>getRealm()) {
            if(!realm.refGetPath().equals(LOGIN_REALM_IDENTITY) && !"Root".equals(realm.refGetPath().getLastSegment().toClassicRepresentation())) {
           		org.openmdx.security.realm1.jmi1.Principal principal = org.opencrx.kernel.backend.SecureObject.getInstance().findPrincipal(id, realm);
           		if(principal != null && !Boolean.TRUE.equals(principal.isDisabled())) {
           			principalName = id;
           			providerName = realm.refGetPath().getSegment(2).toClassicRepresentation();
           			segmentName = realm.refGetPath().getLastSegment().toClassicRepresentation();
           			count++;
           		}
            }
		}
        // id is not unique --> no success
        if(count > 1) {
        	principalName = null;
        }
        pmRoot.close();
    }
	if(principalName != null && providerName != null && segmentName != null) {
		javax.jdo.PersistenceManagerFactory pmf = org.opencrx.kernel.utils.Utils.getPersistenceManagerFactory();
		javax.jdo.PersistenceManager pm = pmf.getPersistenceManager(
			SecurityKeys.ADMIN_PRINCIPAL + SecurityKeys.ID_SEPARATOR + segmentName, 
			null
		);
		try {
			org.opencrx.kernel.home1.jmi1.UserHome userHome = (org.opencrx.kernel.home1.jmi1.UserHome)pm.getObjectById(
				new Path("xri://@openmdx*org.opencrx.kernel.home1").getDescendant("provider", providerName, "segment", segmentName, "userHome", principalName)
			);
			pm.currentTransaction().begin();
			userHome.requestPasswordReset();
			pm.currentTransaction().commit();
			success = true;
		} catch(Exception e) {
			try {
				pm.currentTransaction().rollback();
			} catch(Exception ignore) {}
			success = false;
		}
	} else {
		success = false;
	}
}
```

Within the `application.xml` file, we find the line `<library-directory>APP-INF/lib</library-directory>`, directing us to look within that folder for the libraries. Since our object is found within `opencrx-kernel.jar`, we extract it and find the `UserHome.class` file. 

The `UserHome.class` file is just an interface, which defines a list of methods but does not implement the actual code within those methods. We’ll need to find the class that implements the interface, and so we can search for `requestPasswordReset` in JD-GUI to find other classes with this method. Among them, we find the file `UserHomeImpl.class`, which refers to an interface implementation. 

```java
public Void requestPasswordReset() {
    try {
      UserHomes.getInstance().requestPasswordReset((UserHome)
          sameObject());
      return newVoid();
    } catch (ServiceException e) {
      throw new JmiServiceException(e);
    } 
  }
```

Tracing the `requestPasswordReset` further, we find the actual code that implements the function. Specifically, the `resetToken` variable is set with the function `Utils.getRandomBase62(40);`. We can further follow this method to see its specifics. 

```java
public void requestPasswordReset(UserHome userHome) throws ServiceException {
    PersistenceManager pm = JDOHelper.getPersistenceManager(userHome);
    String providerName = userHome.refGetPath().getSegment(2).toClassicRepresentation();
    String segmentName = userHome.refGetPath().getSegment(4).toClassicRepresentation();
    String principalName = userHome.refGetPath().getLastSegment().toClassicRepresentation();
    Principal loginPrincipal = (Principal)SecureObject.getInstance().findPrincipal(principalName, 
        
        SecureObject.getInstance().getLoginRealmIdentity(userHome
          .refGetPath().getSegment(2).toClassicRepresentation()), pm);
    String webAccessUrl = userHome.getWebAccessUrl();
    if (webAccessUrl != null) {
      String resetToken = Utils.getRandomBase62(40);
      String name = providerName + "/" + segmentName + " Password Reset";
      String resetConfirmUrl = webAccessUrl + (webAccessUrl.endsWith("/") ? "" : "/") + "PasswordResetConfirm.jsp?t=" + resetToken + "&p=" + providerName + "&s=" + segmentName + "&id=" + principalName;
      String resetCancelUrl = webAccessUrl + (webAccessUrl.endsWith("/") ? "" : "/") + "PasswordResetCancel.jsp?t=" + resetToken + "&p=" + providerName + "&s=" + segmentName + "&id=" + principalName;
      String description = getRequestPasswordResetNotificationTemplate(userHome);
      description = description.replace("{RESET_CONFIRM_URL}", resetConfirmUrl);
      description = description.replace("{RESET_CANCEL_URL}", resetCancelUrl);
      Base.getInstance().sendAlert((ContextCapable)userHome, principalName, name, description, (short)2, 
          
          Integer.valueOf(0), null);
      SysLog.warning("Password reset request", Arrays.asList(new String[] { resetConfirmUrl, resetCancelUrl }));
      changePassword((Password)loginPrincipal
          .getCredential(), (String)null, "{RESET}" + resetToken);
    } 
  }
```

The function takes an integer value `length` and returns a randomly generated string that uses `System.currentTimeMillis()` to set the random seed for the number generator. 

```java
public static String getRandomBase62(int length) {
    String alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    Random random = new Random(System.currentTimeMillis());
    String s = "";
    for (int i = 0; i < length; i++)
      s = s + "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".charAt(random.nextInt(62)); 
    return s;
  }
```

## Java Random Libraries

Standard Java libraries have 2 primary random number generators: `java.util.Random` and `java.security.SecureRandom`. 

In the context of `java.util.Random`, an instance generates a stream of pseudorandom numbers based on a specific seed. If 2 instances are created with the same seed and the same sequence of method calls is made for each, they will generate and return identical number sequences. This makes them **not cryptographically secure**. `SecureRandom` produces non-deterministic output and complies with statistical RNG tests in FIPS 140-2. 

As such, if we can predict **when** a token is requested, we can predict the value of `currentTimeMillis` used as the random seed and thus generate a matching token by setting a seed value when creating our own `Random` object.